# .github/workflows/sync-images-to-ghcr.yaml
name: üé´ Sync Images to GHCR (Multi-File)

# Triggers: Run manually or on push/merge to the main branch
on:
  workflow_dispatch: # Allows manual triggering from the GitHub Actions UI
  push:
    branches:
      - main # Or your primary branch name
    paths:
      # CORRECTED: Watch the directory containing the definitions
      - 'docker-image-sync-definitions/**'
      - '.github/workflows/sync-images-to-ghcr.yaml' # Or if the workflow file itself changes

permissions:
  contents: read # Needed to checkout the code and read the YAML file(s)
  packages: write # Needed to write (push) to GitHub Container Registry (GHCR)

jobs:
  # --- Job 1: Read YAML files from directory and prepare the matrix ---
  prepare_matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }} # Export the matrix as an output
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 1: Install yq using wget
      - name: Install yq
        run: |
          echo "‚ÑπÔ∏è Installing yq..."
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
            echo "‚úÖ yq installed."
            echo "üì¶ yq version: $(yq --version)"

      # Step 2: Install jq (needed for JSON processing)
      - name: Install jq
        run: |
          echo "‚ÑπÔ∏è Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
            echo "‚úÖ jq installed."
            echo "üì¶ jq version: $(jq --version)"

      # Step 4: Find YAML files, aggregate data, and generate matrix (with Debug)
      - name: Generate matrix from YAML files
        id: set_matrix
        run: |
          echo "‚ÑπÔ∏è Finding YAML files in docker-image-sync-definitions/ ..."
          # Step 4a: Generate the flat JSON array of image objects
          FLAT_JSON_ARRAY=$(find docker-image-sync-definitions -name '*.yml' -type f -exec yq -o=json --indent 0 '.' {} + | jq -s 'flatten')

          # --- Debug Start: Print Flat Array ---
          echo "--------------------------------------------------"
          echo "DEBUG: Flat JSON Array generated:"
          echo "$FLAT_JSON_ARRAY"
          echo "--------------------------------------------------"
          # --- Debug End ---

          # Step 4b: Construct the final {"include": [...]} structure
          # Using printf for potentially safer string construction if array is huge, though echo should work fine too
          printf -v FINAL_JSON_OUTPUT '{"include":%s}' "$FLAT_JSON_ARRAY"
          # Alternative with echo:
          # FINAL_JSON_OUTPUT="{\"include\":$FLAT_JSON_ARRAY}"

          # --- Debug Start: Print Final Structure ---
          echo "--------------------------------------------------"
          echo "DEBUG: Final JSON structure for matrix output:"
          echo "$FINAL_JSON_OUTPUT"
          echo "--------------------------------------------------"
          # --- Debug End ---

          # Step 4c: Check the generated array and set the output
          # Note: Checking FLAT_JSON_ARRAY as FINAL_JSON_OUTPUT will always have {"include":...}
          if [ -z "$FLAT_JSON_ARRAY" ] || [ "$FLAT_JSON_ARRAY" = "null" ] || [ "$FLAT_JSON_ARRAY" = "[]" ]; then
            echo "‚ö†Ô∏è WARNING: No valid image definitions found or failed to generate JSON array."
            echo "Setting matrix to empty include to prevent downstream errors."
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Matrix JSON generated."
            echo "matrix=$FINAL_JSON_OUTPUT" >> $GITHUB_OUTPUT
          fi

      # Step 5: Display the generated matrix JSON (formatted for readability)
      - name: Display Generated Matrix JSON
        run: |
          echo "--------------------------------------------------"
          echo "Final Matrix Output (formatted by jq):"
          # Use single quotes to pass the literal string to jq
          echo '${{ steps.set_matrix.outputs.matrix }}' | jq '.'
          echo "--------------------------------------------------"

  # --- Job 2: Synchronize images in parallel with retry logic (using Bash) ---
  sync_image:
    needs: prepare_matrix # Depends on the job that prepares the matrix
    # Only run if the matrix is not empty (optional guard)
    # if: needs.prepare_matrix.outputs.matrix != '{"include":[]}'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # If one image fails, others continue
      # Use fromJson with the {"include": [...]} structure generated above
      matrix: ${{ fromJson(needs.prepare_matrix.outputs.matrix) }}
    steps:
      - name: Print Image Details
        run: |
          # Check if matrix context is actually populated (needed if 'if:' condition above is removed)
          if [ -z "${{ matrix.dockerhub_repository }}" ]; then
            echo "‚ö†Ô∏è Skipping step as matrix seems empty."
            exit 0
          fi
          echo "--------------------------------------------------"
          echo "‚è≥ Processing Image:"
          echo "  Docker Hub Repo:    ${{ matrix.dockerhub_repository }}"
          echo "  Docker Hub Tag:     ${{ matrix.dockerhub_tag }}"
          echo "  Docker Hub Digest:  ${{ matrix.dockerhub_digest }}"
          echo "  GHCR Package Name:  ${{ matrix.ghcr_package_name }}"
          echo "  GHCR Tag:           ${{ matrix.ghcr_tag }}"
          echo "--------------------------------------------------"

      - name: Login to GitHub Container Registry
        # if: matrix.dockerhub_repository != '' # Optional condition
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }} # The user or app that triggered the workflow
          password: ${{ secrets.GITHUB_TOKEN }} # Use the automatically generated GITHUB_TOKEN for authentication

      - name: Check, Pull, Tag, and Push Image with Retries (Bash)
        # if: matrix.dockerhub_repository != '' # Optional condition
        env:
          # Environment variables for the script, taken from the matrix
          DH_REPO: ${{ matrix.dockerhub_repository }}
          DH_TAG: ${{ matrix.dockerhub_tag }} # Used for logging, pull uses digest
          DH_DIGEST: ${{ matrix.dockerhub_digest }}
          GHCR_PKG: ${{ matrix.ghcr_package_name }}
          GHCR_TAG: ${{ matrix.ghcr_tag }}
          # Build the full image name on GHCR
          # CORRECTED: Convert github.repository_owner to lowercase using ',,'
          GHCR_IMAGE_FULL_NAME: ghcr.io/${{ github.repository_owner }}/${{ matrix.ghcr_package_name }}:${{ matrix.ghcr_tag }}
          DH_IMAGE_FULL_NAME_DIGEST: ${{ matrix.dockerhub_repository }}@${{ matrix.dockerhub_digest }}
        run: |
          # Bash function to execute a command with retries
          # Arguments:
          # $1: Maximum number of attempts (e.g., 4 = 1 initial attempt + 3 retries)
          # $2: Array of wait times in seconds between attempts (e.g., "30 60 300")
          # $3+: The command to execute
          retry_command() {
            local max_attempts=$1
            local wait_times=($2) # Convert the string to a bash array
            local cmd=("${@:3}") # Get all arguments from the third one onwards as the command
            local attempt=1
            local exit_code=0

            while [ $attempt -le $max_attempts ]; do
              # Indentation preserved for readability within retry loop
              echo "   ‚è≥ Attempt $attempt/$max_attempts: Executing command -> ${cmd[*]}"
              # Execute the command
              "${cmd[@]}"
              exit_code=$?

              # If the command succeeds (exit code 0), exit the function
              if [ $exit_code -eq 0 ]; then
                echo "   ‚úÖ Command executed successfully."
                return 0
              fi

              # If it's the last attempt, exit with failure
              if [ $attempt -eq $max_attempts ]; then
                echo "   ‚ùå ERROR: Command failed after $max_attempts attempts."
                return $exit_code # Return the last exit code
              fi

              # Calculate the index for the wait time (0-based)
              local wait_index=$((attempt - 1))
              # Make sure to use the last wait time if the index is out of bounds
              local wait_time
              if [ $wait_index -lt ${#wait_times[@]} ]; then
                wait_time=${wait_times[$wait_index]}
              else
                # Use the last element if index is out of bounds
                wait_time=${wait_times[-1]}
              fi


              echo "   ‚ö†Ô∏è Command failed with code $exit_code. Waiting ${wait_time}s before next attempt..."
              sleep "$wait_time"
              attempt=$((attempt + 1))
            done
          }

          # Check if required variables are set (needed if 'if:' condition on step is removed)
          if [ -z "$DH_REPO" ] || [ -z "$DH_DIGEST" ] || [ -z "$GHCR_PKG" ] || [ -z "$GHCR_TAG" ]; then
             echo "‚ö†Ô∏è Skipping sync logic due to missing matrix parameters."
             exit 0
          fi


          echo "‚ÑπÔ∏è Checking if image exists in GHCR: $GHCR_IMAGE_FULL_NAME"

          # Check if the image manifest already exists on GHCR
          # `docker manifest inspect` returns a non-zero exit code if the image doesn't exist
          # Redirect stdout and stderr to /dev/null to avoid cluttering the log on success
          if ! docker manifest inspect "$GHCR_IMAGE_FULL_NAME" > /dev/null 2>&1; then
            # --- Image NOT found in GHCR ---
            echo "‚ÑπÔ∏è Not Found! Image is missing from GHCR. Proceeding with pull and push." # User's emoji choice

            # --- PULL with Retry ---
            echo " PULL: Attempting to download image from Docker Hub: $DH_IMAGE_FULL_NAME_DIGEST"
            # 1 initial attempt + 3 retries = 4 total attempts. Waits: 30s, 60s, 300s
            retry_command 4 "30 60 300" docker pull "$DH_IMAGE_FULL_NAME_DIGEST"
            if [ $? -ne 0 ]; then
              echo "‚ùå FATAL ERROR: Pull failed for $DH_IMAGE_FULL_NAME_DIGEST after all attempts."
              exit 1 # Fail the job for this image
            fi
            echo "‚úÖ PULL: Download complete."

            # --- TAG ---
            echo "üè∑Ô∏è TAG: Tagging image for GHCR as $GHCR_IMAGE_FULL_NAME"
            # Apply the GHCR tag to the downloaded image
            docker tag "$DH_IMAGE_FULL_NAME_DIGEST" "$GHCR_IMAGE_FULL_NAME"
            if [ $? -ne 0 ]; then
              echo "‚ùå ERROR: Tagging failed for $GHCR_IMAGE_FULL_NAME"
              exit 1 # Exit with error (tagging usually doesn't require retry)
            fi
            echo "‚úÖ TAG: Tagging complete."

            # --- PUSH with Retry ---
            echo " PUSH: Attempting to upload image to GHCR: $GHCR_IMAGE_FULL_NAME"
            # 1 initial attempt + 3 retries = 4 total attempts. Waits: 30s, 60s, 300s
            retry_command 4 "30 60 300" docker push "$GHCR_IMAGE_FULL_NAME"
            if [ $? -ne 0 ]; then
              echo "‚ùå FATAL ERROR: Push failed for $GHCR_IMAGE_FULL_NAME after all attempts."
              exit 1 # Fail the job for this image
            fi
            echo "‚úÖ PUSH: Upload complete."
            echo "üéâ Success: Image $DH_REPO:$DH_TAG synchronized to GHCR as $GHCR_IMAGE_FULL_NAME" # Changed emoji for final success

          else
            # --- Image ALREADY found in GHCR ---
            echo "‚úÖ Already Exists! Image $GHCR_IMAGE_FULL_NAME is already present in GHCR. Skipping."
          fi
          echo "--------------------------------------------------"
